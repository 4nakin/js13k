{"ts":1347280905288,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1347280915751,"patch":[[{"diffs":[[1,"\nfunction Game(canvas, ctx){\n    var that = this;\n    \n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.width = canvas.width;\n    this.height = canvas.height;\n    this.mouse = {x: this.width/2, y: 0};\n    this.bullets = [];\n    this.enemies = [];\n    this.tower = new Tower(this.width/2, this.height, 10, 20, 'rgb(0,0,0)');\n    this.viewfinder = new Viewfinder(0, 0, 20, 20, 'rgb(0,0,0)');\n    this.toClean = 0;\n    this.enemiesToClean = 0;\n    \n    this.createEnemies = setInterval(function() {\n        that.addEnemy = true;\n    }, 1000);\n    \n}\nGame.prototype.clear = function(){\n    this.ctx.fillStyle = 'rgb(245,245,245)';\n    this.ctx.fillRect( 0, 0, 255, 255 );\n}\n\n\n\nGame.prototype.draw = function(){\n    this.clear();\n    \n    if(this.addBullet){\n        var mouse = this.mouse;\n\n        //todo\n        var atan = game.tower.getRotate(mouse);           \n        game.bullets.push( new Bullet(game.tower.x, game.tower.y, 5, atan, 'rgba(125, 50, 50, 1)') );\n        this.addBullet = false;\n    }\n    if(this.addEnemy){\n        var x = Math.floor(Math.random() * this.width) + 1;\n        game.enemies.push( new Enemy(x, 0, 20, 20, 'rgba(125, 50, 50, 1)') );\n        this.addEnemy = false;\n    }\n    //enemies\n    var enemies = this.enemies;\n    var l = ( enemies && enemies.length) ? enemies.length : 0;\n    for (var i = 0; i < l; i++) {\n      var enemy = enemies[i];\n      \n      // We can skip the drawing of elements that have moved off the screen:\n      if (!enemy || enemy.y > this.height ){\n              \n              enemies[i] = false;\n              this.enemiesToClean++;\n              \n        }else{\n            enemies[i].draw(this.ctx);\n        }\n    }\n    \n    \n    \n    //Bullets\n    var shapes = this.bullets;\n    \n \n    // ** Add stuff you want drawn in the background all the time here **\n    this.tower.draw(this.ctx, this.mouse);\n    this.viewfinder.draw(this.ctx, this.mouse);\n \n    // draw all shapes\n    var l = ( shapes && shapes.length) ? shapes.length : 0;\n    for (var i = 0; i < l; i++) {\n      var shape = shapes[i];\n      \n      // We can skip the drawing of elements that have moved off the screen:\n      if (!shape || shape.x > this.width || shape.y > this.height ||\n          shape.x + shape.w < 0 || shape.y + shape.h < 0 || shape.offset > this.height){\n              \n              shapes[i] = false;\n              this.toClean++;\n              \n        }else{\n            shapes[i].draw(this.ctx);\n        }\n    }\n    \n    if(this.toClean > 2){\n        //console.log('clean', l);\n        this.bullets = shapes.filter(function(e){return e});\n        //console.log('cleaned: ', this.bullets.length);\n        this.toClean = 0;\n    }\n    if(this.enemiesToClean > 2){\n        //console.log('enemies clean', l);\n        this.enemies = enemies.filter(function(e){return e});\n        //console.log('enemies cleaned: ', this.enemies.length);\n        this.enemiesToClean = 0;\n    }\n}"]],"start1":0,"start2":0,"length1":0,"length2":2921}]],"length":2921,"saved":false}
{"ts":1347281057996,"patch":[[{"diffs":[[0,"\n    }\n}"],[1,"\n\n\n\nGame.prototype.getMouse = function(e) {\n  var element = canvas, offsetX = 0, offsetY = 0, mx, my;\n \n  // Compute the total offset\n  if (element.offsetParent !== undefined) {\n    do {\n      offsetX += element.offsetLeft;\n      offsetY += element.offsetTop;\n    } while ((element = element.offsetParent));\n  }\n \n  // Add padding and border style widths to offset\n  // Also add the <html> offsets in case there's a position:fixed bar\n  //offsetX += this.stylePaddingLeft + this.styleBorderLeft + this.htmlLeft;\n  //offsetY += this.stylePaddingTop + this.styleBorderTop + this.htmlTop;\n if( e.targetTouches && e.targetTouches[0] ){\n     mx = e.targetTouches[0].pageX - offsetX;\n     my = e.targetTouches[0].pageY - offsetY;\n }else{\n      mx = e.pageX - offsetX;\n      my = e.pageY - offsetY;\n }\n \n  // We return a simple javascript object (a hash) with x and y defined\n  return {x: mx, y: my};\n}\n\n"]],"start1":2913,"start2":2913,"length1":8,"length2":905}]],"length":3818,"saved":false}
{"ts":1347281517791,"patch":[[{"diffs":[[0,"    var "],[-1,"atan"],[1,"d"],[0," = game."]],"start1":812,"start2":812,"length1":20,"length2":17},{"diffs":[[0,".get"],[-1,"Rotate"],[1,"Diffs"],[0,"(mou"]],"start1":834,"start2":834,"length1":14,"length2":13},{"diffs":[[0," 5, "],[-1,"atan"],[1,"d.dx, d.dy"],[0,", 'r"]],"start1":928,"start2":928,"length1":12,"length2":18},{"diffs":[[0," y: my};\n}\n\n"],[1,"\n"]],"start1":3808,"start2":3808,"length1":12,"length2":13}]],"length":3821,"saved":false}
